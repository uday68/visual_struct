<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Binary Search Visualizer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Visualizer for Binary Indexed Tree (BIT) operations such as prefix sum query and update operation.">
    <meta name="author" content="Interactive Learning for Coders">
    <meta name="keywords" content="Binary Indexed Tree, BIT, Fenwick Tree, Prefix Sum Query, Update Operation, Competitive Programming">
    <meta property="og:title" content="Binary Indexed Tree (BIT) Visualizer">
    <meta property="og:description" content="Visualizer for Binary Indexed Tree (BIT) operations such as prefix sum query and update operation.">
    <meta property="og:url"content="https://www.visual-struct.tech/visualizer/binarysearch">
    <style>
        body {
            font-family:  'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f4f7;
            margin: 0;
            padding: 0;
        }

        .container {
            padding: 20px;
 
            width: 90%;
            margin: 100px auto 30px auto;
            background-color: #2e2e2e;
            border-radius: 10px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
            color: #d4d4d4;
            height: auto;
         
        }
        
        #take-input {
            margin-bottom: 20px;
        }
        
        input {
          padding: 10px;
            font-size: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border-color: linear-gradient(45deg, #6a11cb, #2575fc) 1px solid;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        p {
            color: #34495e;
            margin-bottom: 25px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

     
        .controls button {
            background-color: #2980b9;
            color: #ffffff;
            cursor: pointer;
        }

        .controls button:hover {
            background-color: #1f6391;
        }

        .canvas-container {
            width: 98%;
       
            overflow: hidden;
            margin: 0 0 20px 0;
            border: 2px solid #bdc3c7;
            border-radius: 10px;
            background-color: #f9f9f9;
            padding: 15px;
        }

        canvas {
           margin: 0% 0% 0% 0%;
            height: auto;
            display: block;
        }

        .operation-queue {
            text-align: left;
            margin-bottom: 25px;
        }

        .operation-queue h3 {
            font-size: 1.4rem;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .operation-queue ul {
            list-style-type: none;
            padding-left: 0;
        }

        .operation-queue li {
            background-color: #ecf0f1;
            margin-bottom: 8px;
            padding: 10px 15px;
            border-radius: 5px;
            color: #2c3e50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        

    
            /* Existing Styles */
        
            .result-section {
                text-align: left;
                margin-bottom: 25px;
                padding: 15px; /* Added padding for better spacing */
                background-color: #f9f9f9; /* Optional: Background color for clarity */
                border-radius: 5px; /* Optional: Rounded corners */
                box-sizing: border-box; /* Ensure padding is included in width and height */
                overflow: hidden; /* Prevent child elements from overflowing */
            }
        
            .result-section h2 {
                font-size: 1.6rem;
                color: #2c3e50;
                margin-bottom: 12px;
            }
        
            .result-section p {
                font-size: 1.1rem;
                color: #34495e;
                margin: 6px 0;
            }
        
            /* Responsive Adjustments */
            @media (max-width: 768px) {
                .result-section {
                    padding: 10px; /* Adjust padding for smaller screens */
                }
        
                .result-section h2 {
                    font-size: 1.4rem;
                }
        
                .result-section p {
                    font-size: 1rem;
                }
            }
       

        span {
            font-weight: bold;
            color: #2c3e50;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

          
        }
          button {
            display: inline-block;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            background: linear-gradient(45deg, #6a11cb, #2575fc);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s;
            margin: 0 10px;
        }
        
       button:hover {
            background: linear-gradient(45deg, #2575fc, #6a11cb);
            transform: translateY(-2px);
        }
        
   button:active {
            transform: translateY(0);
        }
      
        pre {
            background-color: #f9f9f9;
            padding: 10px;
            border-left: 5px solid #3498db;
            color: #333;
            font-size: 14px;
            margin: 10px 0;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    {%include 'visualizer.html'%}
    {%block content%}
    <div class="container">
        <h1>Binary Indexed Tree (BIT)</h1>

    <!-- Toggle Buttons -->
    <section class="about-bit">
        <button id="toggle-about">Show About</button>
        <button id="toggle-algorithm">Show Algorithm</button>
        <div id="about-bit-content" style="display: none;">
            <h2>What is a Binary Indexed Tree (Fenwick Tree)?</h2>
            <p>A Binary Indexed Tree (BIT), also called a Fenwick Tree, is a data structure that efficiently performs the following operations:</p>
            <ul>
                <li><strong>Prefix Sum Query:</strong> Calculate the sum of elements in a subarray (from index 1 to i) in logarithmic time.</li>
                <li><strong>Update Operation:</strong> Update the value of an element in the array and propagate the change efficiently.</li>
            </ul>
            <p>It is particularly useful when dealing with dynamic arrays where frequent updates and prefix sum queries are needed, such as in competitive programming.</p>

            <h3>Why Use Binary Indexed Tree?</h3>
            <ul>
                <li>It is an efficient alternative to segment trees for range sum queries.</li>
                <li>The time complexity for both update and prefix sum query is <strong>O(log n)</strong>, where <em>n</em> is the number of elements.</li>
                <li>It works efficiently for arrays with dynamic updates.</li>
            </ul>

            <h3>How Does a Binary Indexed Tree Work?</h3>
            <p>The BIT uses binary indexing to store and retrieve sums efficiently.</p>
            <ul>
                <li><strong>Tree Representation:</strong> The BIT is represented as an array, where each element stores the cumulative sum of a range of array elements.</li>
                <li><strong>Binary Representation:</strong> The binary representation of indices is used to determine the range covered by each node in the tree.</li>
                <li><strong>To update an element:</strong> Modify the value and propagate the changes to all the relevant parent nodes.</li>
                <li><strong>To query the prefix sum:</strong> Accumulate sums while moving through parent nodes.</li>
            </ul>
        </div>
        <div id="algorithm-bit-content" style="display: none;">
            <h3>Algorithm for Binary Indexed Tree</h3>
            <h4>1. Initialize the Binary Indexed Tree</h4>
            <pre>
Input: Array A of size n
Output: Binary Indexed Tree (BIT) initialized
1. Create an array BIT of size (n+1) initialized to 0
2. For i from 1 to n:
  Update BIT with the value A[i] at position i
            </pre>

            <h4>2. Update Operation</h4>
            <pre>
Input: BIT array, position i, value delta
Output: Updated BIT array

1. while i <= size of BIT:
  BIT[i] += delta
  i = i + (i & -i)   // Move to the next parent node
            </pre>

            <h4>3. Query Operation</h4>
            <pre>
Input: BIT array, position i
Output: Sum of elements from index 1 to i

1. sum = 0
2. while i > 0:
  sum += BIT[i]
  i = i - (i & -i)  // Move to the parent node
3. return sum
            </pre>

            <h4>4. Range Sum Query</h4>
            <pre>
Input: BIT array, range l to r
Output: Sum of elements from index l to r

1. result = prefixSum(r) - prefixSum(l-1)
2. return result
            </pre>
        </div>
    </section>
</main>
   
        <div class="controls" id="binarysearch-controls">
            <input type="number" id="input-element" placeholder="Enter element value" min="0">
            <input type="number" id="input-target" placeholder="Enter target value" min="0">
            <button id="add-element">Add Element</button>
            <button id="run-algorithm">Run Binary Search</button>
            <button id="clear-array">Clear Array</button>
            <button id="generate-random">Generate Random Array</button>
            <button id="run-all-operations">Run All Operations</button>
        </div>

        <!-- Operation Queue Section -->
        <div class="operation-queue" id="operation-queue">
            <h3>Operation Queue</h3>
            <ul id="op-queue-list"></ul>
        </div>

        <div class="canvas-container">
            <canvas id="binarysearch-canvas" width="600px" height="600px"></canvas>
        </div>

        <div class="result-section">
            <h2>Results</h2>
            <p><strong>Array:</strong> <span id="array-display">[]</span></p>
            <p><strong>Status:</strong> <span id="status">None</span></p>
        </div>
    </div>
    
    <script>
        // Utility function to wait for a specified time (milliseconds)
        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Binary Search Class for Visualization
        class BinarySearchVisualizer {
            constructor(array, canvas) {
                this.array = array;
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                this.barWidth = 40;
                this.barGap = 20;
                this.startX = 50;
                this.startY = 50;
            }

            // Render the array as bars
            render(highlights = {}) {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Draw bars
                this.array.forEach((value, index) => {
                    const x = this.startX + index * (this.barWidth + this.barGap);
                    const y = this.height - 50 - value * 5; // Scaling for visualization
                    const barHeight = value * 5;
                    
                    // Highlight specific bars
                    if (highlights[index] === 'current') {
                        this.ctx.fillStyle = '#e74c3c'; // Red for current mid
                    } else if (highlights[index] === 'left') {
                        this.ctx.fillStyle = '#3498db'; // Blue for left pointer
                    } else if (highlights[index] === 'right') {
                        this.ctx.fillStyle = '#f1c40f'; // Yellow for right pointer
                    } else if (highlights[index] === 'found') {
                        this.ctx.fillStyle = '#2ecc71'; // Green for found element
                    } else {
                        this.ctx.fillStyle = '#95a5a6'; // Grey for normal bars
                    }

                    this.ctx.fillRect(x, y, this.barWidth, barHeight);
                    this.ctx.strokeStyle = '#2c3e50';
                    this.ctx.strokeRect(x, y, this.barWidth, barHeight);

                    // Label the bars with their values
                    this.ctx.fillStyle = '#2c3e50';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(value, x + this.barWidth / 2, y - 5);
                });
            }

            // Update the array
            updateArray(newArray) {
                this.array = newArray;
                this.render();
            }
        }

        // Visualization Setup
        const canvas = document.getElementById('binarysearch-canvas');
        const ctx = canvas.getContext('2d');
        const addElementButton = document.getElementById('add-element');
        const runAlgorithmButton = document.getElementById('run-algorithm');
        const clearArrayButton = document.getElementById('clear-array');
        const generateRandomButton = document.getElementById('generate-random');
        const runAllButton = document.getElementById('run-all-operations');
        const inputElement = document.getElementById('input-element');
        const inputTarget = document.getElementById('input-target');
        const arrayDisplay = document.getElementById('array-display');
        const statusSpan = document.getElementById('status');
        const opQueueList = document.getElementById('op-queue-list');
        document.getElementById('toggle-about').addEventListener('click', function() {
            const content = document.getElementById('about-bit-content');
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                this.textContent = 'Hide About';
            } else {
                content.style.display = 'none';
                this.textContent = 'Show About';
            }
        });

        document.getElementById('toggle-algorithm').addEventListener('click', function() {
            const content = document.getElementById('algorithm-bit-content');
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                this.textContent = 'Hide Algorithm';
            } else {
                content.style.display = 'none';
                this.textContent = 'Show Algorithm';
            }
            });
        let array = [];
        let visualizer = new BinarySearchVisualizer(array, canvas);
        visualizer.render();
        updateArrayDisplay();

        let operationQueue = [];
        let isProcessing = false;

        // Function to update the array display
        function updateArrayDisplay() {
            arrayDisplay.textContent = JSON.stringify(array);
        }

        // Function to render the operation queue
        function renderOperationQueue() {
            opQueueList.innerHTML = '';
            operationQueue.forEach(op => {
                const li = document.createElement('li');
                li.textContent = `${op.operation}: ${JSON.stringify(op.params)}`;
                opQueueList.appendChild(li);
            });
        }

        // Function to enqueue operations
        function enqueueOperation(operation, params) {
            operationQueue.push({ operation, params });
            renderOperationQueue();
        }

        // Function to process the operation queue
        async function processQueue() {
            if (isProcessing || operationQueue.length === 0) return;
            isProcessing = true;

            while (operationQueue.length > 0) {
                const currentOp = operationQueue.shift();
                renderOperationQueue();

                switch(currentOp.operation) {
                    case 'Add Element':
                        await performAddElement(currentOp.params.value);
                        break;
                    case 'Run Binary Search':
                        await performBinarySearch(currentOp.params.target);
                        break;
                    case 'Clear Array':
                        await performClearArray();
                        break;
                    case 'Generate Random Array':
                        await performGenerateRandomArray();
                        break;
                    default:
                        break;
                }
            }

            isProcessing = false;
            statusSpan.textContent = 'All operations have been executed.';
        }

        // Function to perform adding an element
        async function performAddElement(value) {
            if (isNaN(value)) {
                alert('Please enter a valid number to add.');
                return;
            }
            array.push(value);
            array.sort((a, b) => a - b); // Binary search requires sorted array
            visualizer.updateArray(array);
            updateArrayDisplay();
            statusSpan.textContent = `Added element ${value}.`;
            await wait(1000);
        }

        // Function to perform binary search
        async function performBinarySearch(target) {
            if (array.length === 0) {
                alert('Array is empty. Please add elements first.');
                return;
            }
            statusSpan.textContent = `Running binary search for ${target}...`;

            let left = 0;
            let right = array.length - 1;
            let found = false;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                visualizer.render({
                    [mid]: 'current',
                    [left]: 'left',
                    [right]: 'right'
                });
                statusSpan.textContent = `Checking mid index ${mid} with value ${array[mid]}.`;

                await wait(1000);

                if (array[mid] === target) {
                    visualizer.render({ [mid]: 'found' });
                    statusSpan.textContent = `Element ${target} found at index ${mid}.`;
                    alert(`Element ${target} found at index ${mid}.`);
                    found = true;
                    break;
                } else if (array[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            if (!found) {
                statusSpan.textContent = `Element ${target} not found in the array.`;
                alert(`Element ${target} not found in the array.`);
                visualizer.render();
            }

            await wait(1000);
        }

        // Function to clear the array
        async function performClearArray() {
            array = [];
            visualizer.updateArray(array);
            updateArrayDisplay();
            statusSpan.textContent = 'Array has been cleared.';
            await wait(1000);
        }

        // Function to generate a random array
        async function performGenerateRandomArray() {
            const size = 10;
            array = [];
            for (let i = 0; i < size; i++) {
                array.push(Math.floor(Math.random() * 100));
            }
            array.sort((a, b) => a - b);
            visualizer.updateArray(array);
            updateArrayDisplay();
            statusSpan.textContent = 'Random array generated.';
            await wait(1000);
        }

        // Function to run all operations
        async function runAllOperations() {
            if (operationQueue.length === 0) {
                alert('No operations to run.');
                return;
            }
            await processQueue();
        }

        // Event Listener for Add Element
        addElementButton.addEventListener('click', () => {
            const value = parseInt(inputElement.value);
            if (isNaN(value)) {
                alert('Please enter a valid number to add.');
                return;
            }
            enqueueOperation('Add Element', { value });
            inputElement.value = '';
            if (!isProcessing) {
                processQueue();
            }
        });

        // Event Listener for Run Binary Search
        runAlgorithmButton.addEventListener('click', () => {
            const target = parseInt(inputTarget.value);
            if (isNaN(target)) {
                alert('Please enter a valid target value.');
                return;
            }
            enqueueOperation('Run Binary Search', { target });
            inputTarget.value = '';
            if (!isProcessing) {
                processQueue();
            }
        });

        // Event Listener for Clear Array
        clearArrayButton.addEventListener('click', () => {
            enqueueOperation('Clear Array', {});
            if (!isProcessing) {
                processQueue();
            }
        });

        // Event Listener for Generate Random Array
        generateRandomButton.addEventListener('click', () => {
            enqueueOperation('Generate Random Array', {});
            if (!isProcessing) {
                processQueue();
            }
        });

        // Event Listener for Run All Operations
        runAllButton.addEventListener('click', async () => {
            if (operationQueue.length === 0) {
                alert('No operations to run.');
                return;
            }
            await runAllOperations();
        });

        // Initial Render
        visualizer.render();
    </script>
    {% include 'footer.html'%}
    {%endblock%}
</body>
</html>